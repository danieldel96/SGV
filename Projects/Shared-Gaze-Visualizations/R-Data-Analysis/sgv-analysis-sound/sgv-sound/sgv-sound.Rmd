---
title: "sgv-sound"
output: html_document
date: "2025-04-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## R Markdown

```{r sgv-sound}
library(ARTool)
library(emmeans)
library(dplyr)
library(tidyr)
library(broom)
library(tibble)

# Load your data
data <- read.csv("data/quals_postcond.csv")

data <- data %>%
  filter(Q2 %in% c(1, 2, 3))  # Removes any rows where Q2 is 0 or other unexpected values

# Ensure factors are correctly set
data$participant_id <- factor(data$Q1)
data$sound <- factor(data$sound)
data$visualization <- factor(data$Q2)

# List of question columns
questions <- paste0("Q3_", 1:11)

# Initialize storage
all_anovas <- list()
all_posthocs <- list()

# Loop through each question
for (q in questions) {
  # cat("\n========================\n")
  # cat("Analyzing", q, "\n")
  # cat("========================\n")
  
  formula <- as.formula(paste(q, "~ sound * visualization + (1|participant_id)"))
  model <- art(formula, data = data)
  
  print(anova(model))
  
  # ANOVA: tidy and store
  aov_tbl <- anova(model) %>%
    as_tibble(rownames = "Effect") %>%
    mutate(question = q)
  all_anovas[[q]] <- aov_tbl
  
  # Post-hoc: tidy and store
  posthoc <- emmeans(artlm(model, "sound:visualization"), pairwise ~ sound * visualization)
  print(posthoc)
  ph_tbl <- as_tibble(posthoc$contrasts) %>%
    mutate(question = q)
  all_posthocs[[q]] <- ph_tbl
}

# Combine all results
anova_results <- bind_rows(all_anovas)
posthoc_results <- bind_rows(all_posthocs)

# View or export
#print(anova_results, n = Inf)
#print(posthoc_results, n = Inf)

# Optional: write to CSV
# write.csv(anova_results, "anova_results.csv", row.names = FALSE)
# write.csv(posthoc_results, "posthoc_results.csv", row.names = FALSE)
```


```{r summary stats}

# Drop unused levels (important!)
data$sound <- droplevels(factor(data$sound))
data$visualization <- droplevels(factor(data$Q2))  # assuming Q2 is the visualization factor

data <- data %>%
  filter(Q2 %in% c(1, 2, 3))  # Removes any rows where Q2 is 0 or other unexpected values

# Now convert and recode
data$visualization <- factor(data$Q2)
data$visualization <- recode_factor(data$visualization,
                                    `1` = "Ray",
                                    `2` = "Hover",
                                    `3` = "Outline")

# Reshape from wide to long for Q3_1 to Q3_11
long_data <- data %>%
  pivot_longer(cols = starts_with("Q3_"), names_to = "question", values_to = "value")

# Compute mean and SD grouped by sound, visualization, and question
summary_stats <- long_data %>%
  group_by(sound, visualization, question) %>%
  summarise(
    mean = round(mean(value, na.rm = TRUE), 2),
    sd = round(sd(value, na.rm = TRUE), 2),
    n = n(),
    .groups = "drop"
  )

# Print full table
print(summary_stats, n = Inf)
```

```{r Demographics}
print("Demographics Summary...")
data_demo <- read.csv("data/quals_demographics.csv")
gender <- table(data_demo$Q2)
print(gender)

vision <-table(data_demo$Q4_1)
vrexp <- table(data_demo$Q4_2)

partner <- table(data_demo$Q5)

prior <- table(data_demo$Q6)

print(vision)
print(vrexp)
print(partner)
print(prior)

summary(data_demo)

stdev <- sd(data_demo$Q3, na.rm = TRUE)
print(stdev)
```


```{r PostStudy_old}
# print("PostStudy Summary...")
# data_post <- read.csv("data/quals_poststudy.csv")
# 
# wilcox_test1 <- wilcox.test(data_post$Q2_1, data_post$Q2_2, paired = TRUE)
# print(wilcox_test1)
# 
# wilcox_test2 <- wilcox.test(data_post$Q4_1, data_post$Q4_2, paired = TRUE)
# 
# visualcue <- table(data_post$Q7)
# 
# print(visualcue)
# 
# print(wilcox_test2)
# 
# summary(data_post)
```

```{r postStudy}
library(reshape2)
library(stats)
library(PMCMRplus) # Note: PMCMR package has been succeeded by PMCMRplus

print("PostStudy Summary...")
data_post <- read.csv("data/quals_poststudy.csv")

# Ensure the data is read and displayed correctly
print(head(data_post))

# Prepare data for the Friedman test for Q2 variables
data_long_Q2 <- melt(data_post, id.vars = "Q1", measure.vars = c("Q2_1", "Q2_2", "Q2_4"), variable.name = "Condition_Q2", value.name = "Rank_Q2")

# Perform the Friedman test for Q2 variables
friedman_test_Q2 <- friedman.test(Rank_Q2 ~ Condition_Q2 | Q1, data = data_long_Q2)
print("Friedman Test Result for Q2 variables:")
print(friedman_test_Q2)

# If the Friedman test for Q2 variables is significant, perform post-hoc Wilcoxon signed-rank tests
if (friedman_test_Q2$p.value < 0.05) {
  pairwise_tests_Q2 <- pairwise.wilcox.test(data_long_Q2$Rank_Q2, data_long_Q2$Condition_Q2, p.adjust.method = "bonferroni", paired = TRUE)
  print("Post-hoc Wilcoxon Signed-Rank Test Results for Q2 variables:")
  print(pairwise_tests_Q2)
} else {
  print("No significant difference found by the Friedman test for Q2 variables. Post-hoc tests not performed.")
}

# Prepare data for the Friedman test for Q4 variables
data_long_Q4 <- melt(data_post, id.vars = "Q1", measure.vars = c("Q4_1", "Q4_2", "Q4_4"), variable.name = "Condition_Q4", value.name = "Rank_Q4")

# Perform the Friedman test for Q4 variables
friedman_test_Q4 <- friedman.test(Rank_Q4 ~ Condition_Q4 | Q1, data = data_long_Q4)
print("Friedman Test Result for Q4 variables:")
print(friedman_test_Q4)

# If the Friedman test for Q4 variables is significant, perform post-hoc Wilcoxon signed-rank tests
if (friedman_test_Q4$p.value < 0.05) {
  pairwise_tests_Q4 <- pairwise.wilcox.test(data_long_Q4$Rank_Q4, data_long_Q4$Condition_Q4, p.adjust.method = "bonferroni", paired = TRUE)
  print("Post-hoc Wilcoxon Signed-Rank Test Results for Q4 variables:")
  print(pairwise_tests_Q4)
} else {
  print("No significant difference found by the Friedman test for Q4 variables. Post-hoc tests not performed.")
}

# Visual cue table
if ("Q7" %in% colnames(data_post)) {
  visualcue <- table(data_post$Q7)
  print("Visual cue distribution (Q7):")
  print(visualcue)
}

# Summary of the data
print("Summary of the post study data:")
summary(data_post)
```

```{r focus_analysis_art_anova}
# Load libraries
library(ARTool)
library(tidyverse)

# Load your data
data <- read.csv("data/focus_analysis_results.csv")

# Ensure correct data types
data$study <- as.factor(data$study)
data$sound <- as.factor(data$sound)
data$condition <- as.factor(data$condition)

# ART ANOVA for Eye contact instances
art_eye_contact_instances <- art(eye_contact_instances
 ~ sound * condition + (1|study), data = data)
cat("\nANOVA: eye_contact_instances\n")
print(anova(art_eye_contact_instances))

# ART ANOVA for eye contact time
art_total_eye_contact_time <- art(total_eye_contact_time
 ~ sound * condition + (1|study), data = data)
cat("\nANOVA: total_eye_contact_time\n")
print(anova(art_total_eye_contact_time))

# ART ANOVA for Total Shared Focus
art_total_shared_focus <- art(total_shared_focus ~ sound * condition + (1|study), data = data)
cat("\nANOVA: Total Shared Focus\n")
print(anova(art_total_shared_focus))

# ART ANOVA for Focus Instances
art_focus_instances <- art(focus_instances ~ sound * condition + (1|study), data = data)
cat("\nANOVA: Focus Instances\n")
print(anova(art_focus_instances))

# ART ANOVA for Individual Rotation_Parent Time
art_indiv_rot_time <- art(individual_rotation_parent_time ~ sound * condition + (1|study), data = data)
cat("\nANOVA: Individual Rotation_Parent Time\n")
print(anova(art_indiv_rot_time))

# ART ANOVA for Individual Rotation_Parent Count
art_indiv_rot_count <- art(individual_rotation_parent_count ~ sound * condition + (1|study), data = data)
cat("\nANOVA: Individual Rotation_Parent Count\n")
print(anova(art_indiv_rot_count))
```

```{r focus_analysis_post}
library(emmeans)

# Eye Contact Instances
cat("\nPost-hoc: Eye Contact Instances\n")
posthoc1 <- emmeans(artlm(art_eye_contact_instances, "sound:condition"), pairwise ~ sound * condition)
print(posthoc1)

# Total Eye Contact Time
cat("\nPost-hoc: Total Eye Contact Time\n")
posthoc2 <- emmeans(artlm(art_total_eye_contact_time, "sound:condition"), pairwise ~ sound * condition)
print(posthoc2)

# Total Shared Focus
cat("\nPost-hoc: Total Shared Focus\n")
posthoc3 <- emmeans(artlm(art_total_shared_focus, "sound:condition"), pairwise ~ sound * condition)
print(posthoc3)

# Focus Instances
cat("\nPost-hoc: Focus Instances\n")
posthoc4 <- emmeans(artlm(art_focus_instances, "sound:condition"), pairwise ~ sound * condition)
print(posthoc4)

# Individual Rotation_Parent Time
cat("\nPost-hoc: Individual Rotation_Parent Time\n")
posthoc5 <- emmeans(artlm(art_indiv_rot_time, "sound:condition"), pairwise ~ sound * condition)
print(posthoc5)

# Individual Rotation_Parent Count
cat("\nPost-hoc: Individual Rotation_Parent Count\n")
posthoc6 <- emmeans(artlm(art_indiv_rot_count, "sound:condition"), pairwise ~ sound * condition)
print(posthoc6)
```

```{r danger}
data <- read.csv("data/danger_objects_summary.csv")

# Ensure correct data types
data$study <- as.factor(data$study)
data$sound <- as.factor(data$sound)
data$condition <- as.factor(data$condition)

# ART ANOVA for num_danger_obj
art_num_danger_obj <- art(num_danger_obj
 ~ sound * condition + (1|study), data = data)
cat("\nANOVA: num_danger_obj\n")
print(anova(art_num_danger_obj))

cat("\nPost-hoc: Danger Object\n")
posthoc <- emmeans(artlm(art_num_danger_obj, "sound:condition"), pairwise ~ sound * condition)
print(posthoc)
```

```{r performance}
data <- read.csv("data/sorted_objects_summary.csv")

# Ensure correct data types
data$study <- as.factor(data$study)
data$sound <- as.factor(data$sound)
data$condition <- as.factor(data$condition)

# ART ANOVA for num_sorted_objects
art_num_sorted_objects <- art(num_sorted_objects
 ~ sound * condition + (1|study), data = data)
cat("\nANOVA: num_sorted_objects\n")
print(anova(art_num_sorted_objects))

cat("\nPost-hoc: Sorted Objects\n")
posthoc <- emmeans(artlm(art_num_sorted_objects, "sound:condition"), pairwise ~ sound * condition)
print(posthoc)
```




